#!/usr/bin/env python2.7
# Author: echel0n <echel0n@sickrage.ca>
# URL: https://sickrage.ca
#
# This file is part of SickRage.
#
# SickRage is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# SickRage is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with SickRage.  If not, see <http://www.gnu.org/licenses/>.

"""
Test Provider Result Parsing
When recording new cassettes:
    Set overwrite_cassettes = True
    Delete the cassette yml file with the same base filename as this file in the cassettes dir next to this file
    Be sure to adjust the self.search_strings so they return results. They must be identical to search strings generated by SickRage
"""

from __future__ import unicode_literals

import os
import re
import unittest
from functools import wraps

import six
from vcr_unittest import VCRMixin

import sickrage
from sickrage.core.helpers import validate_url
from sickrage.core.websession import WebSession
from tests import SiCKRAGETestDBCase

overwrite_cassettes = True

disabled_providers = ['bitcannon']

disabled_provider_tests = {
    'Cpasbien': ['test_rss_search', 'test_episode_search', 'test_season_search'],
    'Torrent9': ['test_rss_search', 'test_episode_search', 'test_season_search'],
    'TorrentProject': ['test_rss_search', 'test_episode_search', 'test_season_search'],
    'TokyoToshokan': ['test_rss_search', 'test_episode_search', 'test_season_search'],
    'LimeTorrents': ['test_cache_update', 'test_rss_search', 'test_episode_search', 'test_season_search'],
    'SkyTorrents': ['test_rss_search', 'test_episode_search', 'test_season_search'],
    'ilCorsaroNero': ['test_rss_search', 'test_episode_search', 'test_season_search'],
}

test_string_overrides = {
    'Cpasbien': {'Episode': ['The 100 S02E16'], 'Season': ['The 100 S02']},
    'Torrent9': {'Episode': ['NCIS S14E09'], 'Season': ['NCIS S14']},
    'NyaaTorrents': {'Episode': ['Fairy Tail S2'], 'Season': ['Fairy Tail S2']},
    'TokyoToshokan': {'Episode': ['Fairy Tail S2'], 'Season': ['Fairy Tail S2']},
    'HorribleSubs': {'Episode': ['Fairy Tail S2'], 'Season': ['Fairy Tail S2']},
    'Newpct': {'Episode': ['the-walking-dead/capitulo-86/hdtv/'], 'Season': ['the-walking-dead/capitulo-86/hdtv/']},
}

magnet_regex = re.compile(r'magnet:\?xt=urn:btih:\w{32,40}(:?&dn=[\w. %+-]+)*(:?&tr=(:?tcp|https?|udp)[\w%. +-]+)*')


class ProviderTests(type):
    class ProviderTest(VCRMixin, SiCKRAGETestDBCase):
        provider = None

        def setUp(self):
            super(ProviderTests.ProviderTest, self).setUp()
            self.provider.username = self.username
            self.provider.password = self.password

        @property
        def username(self):  # pylint: disable=no-self-use
            # TODO: Make this read usernames from somewhere
            return ''

        @property
        def password(self):  # pylint: disable=no-self-use
            # TODO: Make this read passwords from somewhere
            return ''

        def search_strings(self, mode):
            _search_strings = {
                'RSS': [''],
                'Episode': ['Game of Thrones S05E08'],
                'Season': ['Game of Thrones S05']
            }
            _search_strings.update(self.provider.cache.search_params)
            _search_strings.update(test_string_overrides.get(self.provider.name, {}))
            return {mode: _search_strings[mode]}

        def magic_skip(func):
            @wraps(func)
            def magic(self, *args, **kwargs):
                if func.func_name in disabled_provider_tests.get(self.provider.name, []):
                    self.skipTest('Test is programmatically disabled for provider {}'.format(self.provider.name))
                func(self, *args, **kwargs)

            return magic

        def _get_vcr_kwargs(self):
            """Don't allow the suite to write to cassettes unless we say so"""
            if overwrite_cassettes:
                return {'record_mode': 'new_episodes'}
            return {'record_mode': 'once'}

        def _get_cassette_name(self):
            """Returns the filename to use for the cassette"""
            return os.path.join(self.TESTDIR, 'providers/cassettes/{}.yaml'.format(self.provider.id))

        def shortDescription(self):
            if self._testMethodDoc and self.provider:
                return self._testMethodDoc.replace('the provider', self.provider.name)
            return None

        @magic_skip
        def test_rss_search(self):
            """Check that the provider parses rss search results"""
            results = self.provider.search(self.search_strings('RSS'))

            if self.provider.enable_daily:
                self.assertTrue(self.cassette.requests)
                self.assertTrue(results, self.cassette.requests[-1].url)
                self.assertTrue(len(self.cassette))

        @magic_skip
        def test_episode_search(self):
            """Check that the provider parses episode search results"""
            results = self.provider.search(self.search_strings('Episode'))

            self.assertTrue(self.cassette.requests)
            self.assertTrue(results, results)
            self.assertTrue(results, self.cassette.requests[-1].url)
            self.assertTrue(len(self.cassette))

        @magic_skip
        def test_season_search(self):
            """Check that the provider parses season search results"""
            results = self.provider.search(self.search_strings('Season'))

            self.assertTrue(self.cassette.requests)
            self.assertTrue(results, self.cassette.requests[-1].url)
            self.assertTrue(len(self.cassette))

        def test_url(self):
            resp = WebSession(cache=False).get(self.provider.urls['base_url'], timeout=30)
            self.assertTrue(self.provider.urls['base_url'] in resp.url,
                            '{} redirected to {}'.format(self.provider.urls['base_url'], resp.url))
            self.assertTrue(resp.status_code in [200, 403],
                            '{} returned a status code of {}'.format(resp.url, resp.status_code))

        @unittest.skip('Not yet implemented')
        def test_cache_update(self):
            """Check that the provider's cache parses rss search results"""
            self.provider.cache.update()

        def test_result_values(self):
            """Check that the provider returns results in proper format"""
            results = self.provider.search(self.search_strings('Episode'))
            for result in results:
                self.assertIsInstance(result, dict)
                self.assertEqual(sorted(result.keys()), ['leechers', 'link', 'seeders', 'size', 'title'])

                self.assertIsInstance(result['title'], six.text_type)
                self.assertIsInstance(result['link'], six.text_type)
                self.assertIsInstance(result['seeders'], six.integer_types)
                self.assertIsInstance(result['leechers'], six.integer_types)
                self.assertIsInstance(result['size'], six.integer_types)

                self.assertTrue(len(result['title']))
                self.assertTrue(len(result['link']))
                self.assertTrue(result['seeders'] >= 0)
                self.assertTrue(result['leechers'] >= 0)
                self.assertTrue(result['size'] >= -1)

                if result['link'].startswith('magnet'):
                    self.assertTrue(magnet_regex.match(result['link']))
                else:
                    self.assertTrue(validate_url(result['link']))

                self.assertIsInstance(self.provider._get_size(result), six.integer_types)
                self.assertTrue(all(self.provider._get_title_and_url(result)))
                self.assertTrue(self.provider._get_size(result))

        @unittest.skip('Not yet implemented')
        def test_season_search_strings_format(self):
            """Check format of the provider's season search strings"""
            pass

        @unittest.skip('Not yet implemented')
        def test_episode_search_strings_format(self):
            """Check format of the provider's season search strings"""
            pass


for providerID, providerObj in sickrage.app.search_providers.torrent().items():
    if not providerID in disabled_providers:
        if not providerObj.private:
            klassname = b"{}Tests".format(providerObj.name)
            globals()[klassname] = type(klassname, (ProviderTests.ProviderTest,), {'provider': providerObj})

if __name__ == '__main__':
    print("=========================")
    print("STARTING - PROVIDER TESTS")
    print("=========================")
    print("######################################################################")
    unittest.main()
